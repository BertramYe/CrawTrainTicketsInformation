# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file '.\crawtickets\windows.ui'
#
# Created by: PyQt5 UI code generator 5.15.6
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.



import sys
from PyQt5 import QtCore, QtGui, QtWidgets,Qt
# 导入特定的GUI包
from PyQt5.QtGui import QPalette,QPixmap,QColor
from PyQt5.QtGui import QStandardItemModel,QStandardItem
from PyQt5.QtWidgets import QHeaderView,QAbstractItemView

# 车票查询模块
import query_tickets
# 数据库操作模块
import opreation_sqlite3
# 错误检查模块
import error_codes

class Ui_MainWindow(object):
    def __init__(self):
        self.label_title_img_qpixmap = QPixmap('img/bg1.png')   # 头部背景图片背景图片
        self.widget_query_qpixmap = QPixmap('img/bg2.png')      # 查询输入框容器背景图
        self.widget_train_type_qpixmap = QPixmap('img/bg3.png') # 车次类型容器背景图
        self.label_train_img_qpixmap = QPixmap('img/bg4.png')   # 车次信息的分类图表头部图片
        self.palette = QPalette()        # 暂时共用一个调色板
        self.completer_list = opreation_sqlite3.get_all_staion_chinese_name()   # 因为之前已经存过数据了，故而让窗口一启动就提前将结果查出并存下来，减少压力
        # 自定义一个字典集合用来定义某些车子类型是否被勾选
        # 默认假设是都没勾选的 为 False
        self.train_type_checked_or_not_list = {
            'G': False,     # G-高铁
            'D': False,     # D-动车
            'Z': False,     # Z-直达
            'T': False,     # T-特快
            'K': False      # K-快速
        }
        # 自定义一个flag变量来记录，查询按钮有没有被点击过
        self.pushButton_query_clicked_or_not = False
        # 用于存储最终我们所要获取的车票信息，随着这一点可以在数据库里面建立一张临时的表，并且将数据存在数据库里面，
        self.all_tickets_info_list = []


    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(960, 960)
        MainWindow.setMinimumSize(QtCore.QSize(0, 0))
        MainWindow.setMaximumSize(QtCore.QSize(960, 960))
        MainWindow.setBaseSize(QtCore.QSize(0, 0))
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setMinimumSize(QtCore.QSize(96, 96))
        self.centralwidget.setMaximumSize(QtCore.QSize(960, 960))
        self.centralwidget.setBaseSize(QtCore.QSize(0, 0))
        self.centralwidget.setObjectName("centralwidget")

        # UI头部区域
        self.label_title_img = QtWidgets.QLabel(self.centralwidget)
        self.label_title_img.setGeometry(QtCore.QRect(0, 0, 960, 148))
        self.label_title_img.setMinimumSize(QtCore.QSize(960, 148))
        self.label_title_img.setMaximumSize(QtCore.QSize(960, 148))
        self.label_title_img.setSizeIncrement(QtCore.QSize(0, 0))
        self.label_title_img.setBaseSize(QtCore.QSize(0, 0))
        self.label_title_img.setObjectName("label_title_img")
        
        # 爬取的相关信息显示表头部图片
        self.label_train_img = QtWidgets.QLabel(self.centralwidget)
        self.label_train_img.setGeometry(QtCore.QRect(0, 323, 960, 62))
        self.label_train_img.setMinimumSize(QtCore.QSize(960, 62))
        self.label_train_img.setMaximumSize(QtCore.QSize(960, 62))
        self.label_train_img.setObjectName("label_train_img")
        
        # 爬取的相关信息显示表
        self.information_tableView = QtWidgets.QTableView(self.centralwidget)
        self.information_tableView.setGeometry(QtCore.QRect(0, 385, 960, 400))
        self.information_tableView.setMinimumSize(QtCore.QSize(960, 400))
        self.information_tableView.setMaximumSize(QtCore.QSize(960, 400))
        self.information_tableView.setObjectName("information_tableView")
        # 设置数据的存储模式
        self.information_tableView_model = QStandardItemModel()
        # 根据空间自动改变列宽度并且不可修改列宽度
        self.information_tableView.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        # 设置横向表头可见
        self.information_tableView.horizontalHeader().setVisible(False)
        # 设置纵向表头不可见
        self.information_tableView.verticalHeader().setVisible(False)
        # 设置表格内容的文字格式
        self.information_tableView_font = QtGui.QFont()
        self.information_tableView_font.setPointSize(10)
        self.information_tableView.setFont(self.information_tableView_font)
        # 设置表格内的内容不可编辑
        self.information_tableView.setEditTriggers(QAbstractItemView.NoEditTriggers)
        # 垂直滚动条始终开启
        self.information_tableView.setVerticalScrollBarPolicy(Qt.Qt.ScrollBarAlwaysOn)



        # 查询相关的控件的容器
        self.widget_query = QtWidgets.QWidget(self.centralwidget)
        self.widget_query.setGeometry(QtCore.QRect(0, 148, 960, 80))
        self.widget_query.setMinimumSize(QtCore.QSize(960, 80))
        self.widget_query.setMaximumSize(QtCore.QSize(960, 80))
        self.widget_query.setObjectName("widget_query")
        # 设置容器的背景图片
        # 1. 开启自动填充背景功能
        self.widget_query.setAutoFillBackground(True)  
        # 2. 实例化调色板对象和图片对象
        # palette = QPalette()    # 调色板对象
        # widget_query_qpixmap = QPixmap('img/bg2.png')   # 图片对象
        # 3. 指定调色板背景图片（填充背景图片）
        self.palette.setBrush(QPalette.Background,QtGui.QBrush(self.widget_query_qpixmap))
        # 4. 设置调色板
        self.widget_query.setPalette(self.palette)

        self.label_start = QtWidgets.QLabel(self.widget_query)
        self.label_start.setGeometry(QtCore.QRect(20, 30, 60, 16))
        self.label_start.setObjectName("label_start")

        # 出发地输入框，为了减少错误，我直接改成下拉框，并且带上了下拉自动补全功能，同时借助了数据库，此处更加体现了数据库的优势
        # self.textEdit_start = QtWidgets.QTextEdit(self.widget_query)
        # self.textEdit_start.setGeometry(QtCore.QRect(80, 25, 100, 30))
        # self.textEdit_start.setMinimumSize(QtCore.QSize(100, 30))
        # self.textEdit_start.setMaximumSize(QtCore.QSize(100, 30))
        # self.textEdit_start.setObjectName("textEdit_start")
        self.comboBox_start = QtWidgets.QComboBox(self.widget_query)
        self.comboBox_start.setGeometry(QtCore.QRect(80, 25, 100, 30))
        self.comboBox_start.setObjectName("comboBox_start")
        # self.comboBox_start.addItems(opreation_sqlite3.get_all_staion_chinese_name())
        # 打开combox的编辑功能
        self.comboBox_start.setEditable(True)
        # 可以增加一个函数用来触发comboBox_start的自动补全功能，但是不建议这么做
        # 因为这里面相当于一个轮询，造成的结果是程序会多次创建QCompleter对象，造成线程崩溃程序自动强制退出
        # editTextChanged表示里面的内容发生了改变
        # self.comboBox_start.editTextChanged.connect(self.comboBox_start_completer_function)
        # 增加自动补全
        self.comboBox_start_completer =QtWidgets.QCompleter(self.completer_list)
        # 设置匹配模式 有三种： Qt.MatchStartsWith 开头匹配（默认） Qt.MatchContains 内容匹配 Qt.MatchEndsWith 结尾匹配
        self.comboBox_start_completer.setFilterMode(Qt.Qt.MatchContains)
        # 设置补全模式 有三种： QCompleter.PopupCompletion（默认） QCompleter.InlineCompletion  QCompleter.UnfilteredPopupCompletion
        self.comboBox_start_completer.setCompletionMode( QtWidgets.QCompleter.PopupCompletion)
        # 给comboBox_start设置补全器
        self.comboBox_start.setCompleter(self.comboBox_start_completer)
        
        # 目的地
        self.label_target = QtWidgets.QLabel(self.widget_query)
        self.label_target.setGeometry(QtCore.QRect(210, 30, 60, 16))
        self.label_target.setObjectName("label_target")
        # 目的地输入框,同样是为了方便用户，我也改成了下拉输入联想选项框
        # self.textEdit_target = QtWidgets.QTextEdit(self.widget_query)
        # self.textEdit_target.setGeometry(QtCore.QRect(280, 25, 100, 30))
        # self.textEdit_target.setMinimumSize(QtCore.QSize(100, 30))
        # self.textEdit_target.setMaximumSize(QtCore.QSize(100, 30))
        # self.textEdit_target.setObjectName("textEdit_target")
        self.comboBox_target = QtWidgets.QComboBox(self.widget_query)
        self.comboBox_target.setGeometry(QtCore.QRect(280, 25, 100, 30))
        self.comboBox_target.setObjectName("comboBox_target")
        # self.comboBox_target.addItems(opreation_sqlite3.get_all_staion_chinese_name())
        # 打开combox的编辑功能
        self.comboBox_target.setEditable(True)
        # 可以增加一个函数用来触发comboBox_target的自动补全功能，但是不建议，
        # 因为这里面相当于一个轮询，造成的结果是程序会多次创建QCompleter对象，造成线程重复崩溃
        # editTextChanged表示里面的内容发生了改变
        # self.comboBox_target.editTextChanged.connect(self.comboBox_target_completer_function)
        # 增加自动补全
        self.comboBox_target_completer = QtWidgets.QCompleter(self.completer_list)
        # 设置匹配模式 有三种： Qt.MatchStartsWith 开头匹配（默认） Qt.MatchContains 内容匹配 Qt.MatchEndsWith 结尾匹配
        self.comboBox_target_completer.setFilterMode(Qt.Qt.MatchContains)
        # 设置补全模式 有三种： QCompleter.PopupCompletion（默认） QCompleter.InlineCompletion  QCompleter.UnfilteredPopupCompletion
        self.comboBox_target_completer.setCompletionMode( QtWidgets.QCompleter.PopupCompletion)
        # 给comboBox_start设置补全器
        self.comboBox_target.setCompleter(self.comboBox_target_completer)
        

        # 出发日
        self.label_start_date = QtWidgets.QLabel(self.widget_query)
        self.label_start_date.setGeometry(QtCore.QRect(410, 30, 60, 16))   #左、顶、宽和高
        self.label_start_date.setObjectName("label_start_date")
        # 出发日输入框,可以选择日期下拉
        # self.textEdit_start_date = QtWidgets.QTextEdit(self.widget_query)
        # self.textEdit_start_date.setGeometry(QtCore.QRect(470, 25, 100, 30))
        # self.textEdit_start_date.setMinimumSize(QtCore.QSize(100, 30))
        # self.textEdit_start_date.setMaximumSize(QtCore.QSize(100, 30))
        # self.textEdit_start_date.setObjectName("textEdit_start_date")

        self.dateEdit_start = QtWidgets.QDateEdit(self.widget_query)
        self.dateEdit_start.setGeometry(QtCore.QRect(470, 25, 100, 30))
        self.dateEdit_start.setObjectName("dateEdit_start")
        # 设置允许出现日期下拉框
        self.dateEdit_start.setCalendarPopup(True)
        # 设置默认时间为系统的当天时间
        self.dateEdit_start.setDateTime(self.dateEdit_start.dateTime().currentDateTime())




        # 查询按钮
        self.pushButton_query = QtWidgets.QPushButton(self.widget_query)
        self.pushButton_query.setGeometry(QtCore.QRect(620, 25, 100, 30))
        self.pushButton_query.setMinimumSize(QtCore.QSize(100, 30))
        self.pushButton_query.setMaximumSize(QtCore.QSize(100, 30))
        self.pushButton_query.setObjectName("pushButton_query")
        
        # 交通工具标签的容器
        self.widget_train_type = QtWidgets.QWidget(self.centralwidget)
        self.widget_train_type.setGeometry(QtCore.QRect(0, 228, 960, 80))
        self.widget_train_type.setMinimumSize(QtCore.QSize(960, 80))
        self.widget_train_type.setMaximumSize(QtCore.QSize(960, 80))
        self.widget_train_type.setObjectName("widget_train_type")
        # 设置交通工具容器的背景图片
        # 1. 开启自动填充背景功能
        self.widget_train_type.setAutoFillBackground(True)  
        # 2. 实例化调色板对象
        # palette = QPalette()
        # 3. 指定调色板背景图片
        self.palette.setBrush(QPalette.Background,QtGui.QBrush(self.widget_train_type_qpixmap))
        # 4. 设置调色板
        self.widget_train_type.setPalette(self.palette)

        # 一些简单的数据筛选
        self.label_train_type = QtWidgets.QLabel(self.widget_train_type)
        self.label_train_type.setGeometry(QtCore.QRect(20, 40, 72, 15))
        self.label_train_type.setObjectName("label_train_type")
        # 勾选是否是高铁
        self.checkBox_high_speed_trian = QtWidgets.QCheckBox(self.widget_train_type)
        self.checkBox_high_speed_trian.setGeometry(QtCore.QRect(100, 40, 91, 19))
        self.checkBox_high_speed_trian.setObjectName("checkBox_high_speed_trian")
        # 勾选是否是动车
        self.checkBox_motor_train = QtWidgets.QCheckBox(self.widget_train_type)
        self.checkBox_motor_train.setGeometry(QtCore.QRect(220, 40, 91, 19))
        self.checkBox_motor_train.setObjectName("checkBox_motor_train")
        # 勾选是否是直达车次
        self.checkBox_through_train = QtWidgets.QCheckBox(self.widget_train_type)
        self.checkBox_through_train.setGeometry(QtCore.QRect(320, 40, 91, 19))
        self.checkBox_through_train.setObjectName("checkBox_through_train")
        # 勾选是否是特快车
        self.checkBox_express_train = QtWidgets.QCheckBox(self.widget_train_type)
        self.checkBox_express_train.setGeometry(QtCore.QRect(430, 40, 91, 19))
        self.checkBox_express_train.setObjectName("checkBox_express_train")
        # 勾选是否是快速车
        self.checkBox_fast_train = QtWidgets.QCheckBox(self.widget_train_type)
        self.checkBox_fast_train.setGeometry(QtCore.QRect(550, 40, 91, 19))
        self.checkBox_fast_train.setObjectName("checkBox_fast_train")
        
        
        self.information_tableView.raise_()
        self.label_title_img.raise_()
        self.label_train_img.raise_()
        self.widget_query.raise_()
        self.widget_train_type.raise_()
        MainWindow.setCentralWidget(self.centralwidget)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "快手查票"))  # UI主窗体的标题
        
        self.label_title_img.setPixmap(self.label_title_img_qpixmap)      # 设置头部背景图片
        self.label_train_img.setPixmap(self.label_train_img_qpixmap)       # 设置车次详细信息的背景图片

        self.label_start.setText(_translate("MainWindow", "出发地："))
        self.label_target.setText(_translate("MainWindow", "目的地："))
        self.label_start_date.setText(_translate("MainWindow", "出发日："))
        self.pushButton_query.setText(_translate("MainWindow", "查询"))
        # 查询动作出发的点击事件,注意点击事件的详细方法不要用（）,写方法名即可
        self.pushButton_query.clicked.connect(self.pushButton_query_click)
        
        # 对不同类型的车次的筛选
        self.label_train_type.setText(_translate("MainWindow", "车次类型："))
        self.checkBox_high_speed_trian.setText(_translate("MainWindow", "G-高铁"))
        # 加入lambda是为了让控件checkBox触发事件时函数能够传参进去
        # 因为connect后面函数是利用信号槽引用而不是调用，所以必须加上一个隐函数lambda（匿名函数）
        # 否则就会报错TypeError: argument 1 has unexpected type 'NoneType'
        self.checkBox_high_speed_trian.stateChanged.connect(lambda:self.checkbox_state_changed(self.checkBox_high_speed_trian,'G'))
        self.checkBox_motor_train.setText(_translate("MainWindow", "D-动车"))
        self.checkBox_motor_train.stateChanged.connect(lambda:self.checkbox_state_changed(self.checkBox_motor_train,'D'))
        self.checkBox_through_train.setText(_translate("MainWindow", "Z-直达"))
        self.checkBox_through_train.stateChanged.connect(lambda:self.checkbox_state_changed(self.checkBox_through_train,'Z'))
        self.checkBox_express_train.setText(_translate("MainWindow", "T-特快"))
        self.checkBox_express_train.stateChanged.connect(lambda:self.checkbox_state_changed(self.checkBox_express_train,'T'))
        self.checkBox_fast_train.setText(_translate("MainWindow", "K-快速"))
        self.checkBox_fast_train.stateChanged.connect(lambda:self.checkbox_state_changed(self.checkBox_fast_train,'K'))

    # 一些关于windows内的控件的点击事件
    # pushButton_query控件查询的事件
    def pushButton_query_click(self):
        # from_station='合肥'
        # 获取出发地的值，并且去除前后空格
        # from_station=self.textEdit_start.toPlainText().strip()
        from_station_chinese=self.comboBox_start.currentText().strip()
        # 检查出发地的输入的值是否正确
        from_station = error_codes.check_and_transfer_input_station(from_station_chinese,'出发地输入有误！')
        if  not from_station:
            # 如果返回False,代表输入有误，结束程序，直接return出去
            # 否则将检查的结果作为输出进行查询
            return

        # to_station='北京'
        # 获取目的地的值，并且去除前后空格
        # to_station=self.textEdit_target.toPlainText().strip()
        to_station_chinese=self.comboBox_target.currentText().strip()
        # 输入的目的地不能为空值
        to_station = error_codes.check_and_transfer_input_station(to_station_chinese,'目的地输入有误！')
        if  not to_station:
            # 如果返回False,代表输入有误，结束程序，直接return出去
            # 否则将检查的结果作为输出进行查询
            return
        # train_date = '2022-04-25'
        # 获取出发时间，但是本质上最好不要用textEdit的方式去做，最好用日历表去处理
        # train_date = self.textEdit_start_date.toPlainText().strip()
        # current_date = self.dateEdit_start.dateTime().currentDateTime()
        input_train_date = self.dateEdit_start.dateTime()
        train_date = error_codes.check_and_transfer_train_date(input_train_date,'日期输入有误！')
        if not train_date:
            # 如果返回False,代表时间的输入有误，可能是早于当前的时间，这样是查不到车票信息的，为了阻止继续走下面的逻辑，
            # 直接return出去，否则将检查的结果作为输出进行查询
            return  
        # train_date = self.dateEdit_start.dateTime().toString('yyyy-MM-dd')   # yyyy-MM-dd 用于格式化我们想要的输出内容，此时MM代表月份mm代表分钟

        
        # 查询我们想要的内容的结果
        try:
            # 如果在请求车票信息过程中报错，那就直接报错，并显示出我们自定义的错误信息出来，并return不会导致程序崩溃
            # 这一步非常关键，是为了查询当天输入框内的所有的车次的车票信息
            # 其实这里面self.all_tickets_info_list也可以将结果存在数据库里面，这里我用了一个临时全局变量去存的，道理基本都一样，
            # 但是临时变量可能会稍微快一点
            self.all_tickets_info_list = query_tickets.get_tickets_infor(from_station,to_station,train_date)
            # 在新的功能里，为了显示部分我们想要的结果，并且做到实时刷新，我们可能需要先将查询得到的结果存储到一个数据库表格里面，
            # 并且这个表可以是个临时表，每次点击查询动作，都会进行一次重建，在这样可以保证数据的完整性
            # 此时可见我们的临时数据库多么有用
            all_filtered_tickets_info_list = query_tickets.filter_train_infor_with_train_type(self.train_type_checked_or_not_list,self.all_tickets_info_list)
        except Exception as error:
            error_codes.show_error_message('车票信息查询完毕！',406,error)
            return
        # 显示我们查询的结果信息
        self.show_tableView_information(self.information_tableView_model,self.information_tableView,all_filtered_tickets_info_list)
        

    def show_tableView_information(self,target_tableView_model,target_tableView,target_tableView_data_list):
        """ 将我们的目标数据显示在表格里面  """
        # 每次显示之前都要将之前的数据表的数据内容给清除掉
        target_tableView_model.clear()
        # 检查我们查询的结果信息
        if target_tableView_data_list.__len__()==0:
            # 如果没查到就弹窗提示
            error_codes.show_error_message('车票信息查询完毕！',404)
        else:
            # 否则就显示我们查询的结果
            for table_row in range(target_tableView_data_list.__len__()):
                for table_column in range(target_tableView_data_list[table_row].__len__()):
                    table_item = QStandardItem(target_tableView_data_list[table_row][table_column])
                    target_tableView_model.setItem(table_row,table_column,table_item)
            # 设置表格的存储模式，也就是在表里面显示数据而已
            target_tableView.setModel(target_tableView_model)
            self.pushButton_query_clicked_or_not = True
    
    def checkbox_state_changed(self,target_check_box,train_type):
        """ 当checkbox状态发生改变时所触发的事件 """
        # 以下是新的方案处理某些车次被勾选的情况，同时减少的request请求的次数
        # 将默认定义的一些train_type_checked_or_not_list车次的信息进行赋值
        self.train_type_checked_or_not_list[train_type] = target_check_box.isChecked()
        # 如果 pushButton_query 被点击过，并且查到过数据，那么每次checkbox状态改变时，都会默认的触发一次点击事件，
        # 这样就实现了，随着checkbox状态的改变都更新一次数据，虽然这是比较偷懒的做法
        if self.pushButton_query_clicked_or_not:
            all_filtered_tickets_info_list = query_tickets.filter_train_infor_with_train_type(self.train_type_checked_or_not_list,self.all_tickets_info_list)
            self.show_tableView_information(self.information_tableView_model,self.information_tableView,all_filtered_tickets_info_list)


def show_windows(show_windows_or_not):
    """ 主窗口界面 """
    app = QtWidgets.QApplication(sys.argv)    # 实例化QApplication类，作为GUI主程序入口
    main_windows = QtWidgets.QMainWindow()    # 创建一个主窗口对象
    ui = Ui_MainWindow()                      # 实例化UI类
    ui.setupUi(main_windows)                  # 设置窗口UI
    # 是否显示窗口主窗口
    if show_windows_or_not:
        main_windows.show()                   # 显示窗口
    else:
        # 不显示，弹出错误信息
        # 目前定义的错误信息，主要是车站信息的下载是否成功
        error_codes.show_error_message('主窗口启动失败！',405)
    sys.exit(app.exec_())                     # 当窗口被创建，主循环结束





